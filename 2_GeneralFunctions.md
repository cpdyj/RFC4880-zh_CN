# 2. 一般函数

OpenPGP 使用以下核心技术为消息和数据文件提供完整性服务：

- 数字签名
- 加密
- 压缩
- Radix-64 转换

更多的，OpenPGP 提供密钥管理和证书服务，但是这大多超过了本文档的范围。

# 2.1. 通过加密保密

OpenPGP 整合了公钥加密和对称加密以提供保密性。当加密时，对象首先使用一个对称加密算法加密，每个对称密钥只被每个单独的对象使用一次。一个新的“会话密钥”通过随机数生成。自从它第一次被使用，会话密钥绑定到消息并跟随消息被一起传送。为了保护这个密钥，它使用接收者的公钥加密。整个流程如下所示：

1. 发送者创建一个消息
2. 发送者的 OpenPGP 生成一个随机数仅用作这个消息的会话密钥
3. 使用每个接收者的公钥加密会话密钥，这些“被加密的会话密钥”作为消息的开头
4. 发送者的 OpenPGP 使用会话密钥加密消息，这构成了消息的其余部分。注意通常消息是压缩的。
5. 接收者的 OpenPGP 使用接收者的私钥解密会话密钥
6. 接收者的 OpenPGP 使用会话密钥解密消息，如果消息加密了，它将被解密。

伴随着对称密钥加密，可以使用派生自密码短语（或其他共享秘密）的对称密钥，也可以使用类似于上述的公钥算法的两部机制，其中会话密钥使用派生自共享秘密的对称密钥加密。

数字签名和加密服务也许被添加到同一个消息中。首先，一个关于此消息的数字签名将被生成并附加到此消息中。然后，消息加数字签名将使用对称的会话密钥加密。最后，会话密钥使用公钥加密并附加到加密块前。

# 2.2 通过数字签名认证
数字签名使用哈希代码和消息摘要算法，和一个公钥签名算法。整个流程如下所示：

1. 发送者创建一个消息
2. 发送软件生成此消息的哈希代码
3. 发送软件使用发送者的私钥生成签名
4. 二进制签名被附加到消息
5. 接收软件保留一份消息签名的拷贝
6. 接收软件为收到的消息生成一个新的哈希代码，并使用消息签名验证。如果验证成功，消息被认证接收。

# 2.3. 压缩

OpenPGP 实现应该在添加数字签名后加密消息前压缩数据。

如果一个实现未实现压缩，它的作者应当意识到这个世界上的大多数 OpenPGP 消息都是压缩的。也就是说，对于空间受限的实现，实现解压而不是压缩是明智的。

更多的，压缩有个额外的副作用，即某些类型的攻击可能会因稍微更改的压缩数据很少在没有严重错误的情况下解压缩而受到阻碍。这虽然不严格，但在操作上是有用的。通过实现和使用修改检测代码 (MDC)，可以严格防止这些攻击，如以下各节所述。

# 2.4. 转换到 Radix-64

OpenPGP 依赖消息的本机原生表示，数字签名证书和密钥都是一串任意的字节流。一些系统只允许使用由块组成的 7-bit 可打印文本。为了通过对原始二进制数据不安全的通道传输openpgp的原始 8-bit 字节，需要对这些 8-bit 字节进行可打印编码。openpgp提供将原始 8-bit 字节流转换为可打印的 ASCII 字符流的服务，称为 Radix-64 编码或 ASCII 外壳。
实现应当提供 Radix-64 转换。

# 2.5. 仅签名应用

OpenPGP 被设计用于加密和签名，但是有相当数量的问题被仅签名应用解决。即使标准需要加密和签名，但是一些仅省略了加密的不一致的子集实现是合理的。
